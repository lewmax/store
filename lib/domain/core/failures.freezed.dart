// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ValueFailure<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res, ValueFailure<T>>;
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res, $Val extends ValueFailure<T>>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InvalidEmailCopyWith<T, $Res> {
  factory _$$InvalidEmailCopyWith(
          _$InvalidEmail<T> value, $Res Function(_$InvalidEmail<T>) then) =
      __$$InvalidEmailCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidEmailCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidEmail<T>>
    implements _$$InvalidEmailCopyWith<T, $Res> {
  __$$InvalidEmailCopyWithImpl(
      _$InvalidEmail<T> _value, $Res Function(_$InvalidEmail<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
  }) {
    return _then(_$InvalidEmail<T>(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidEmail<T> implements InvalidEmail<T> {
  const _$InvalidEmail({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidEmail(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidEmail<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidEmailCopyWith<T, _$InvalidEmail<T>> get copyWith =>
      __$$InvalidEmailCopyWithImpl<T, _$InvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidEmail?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidEmail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail<T> implements ValueFailure<T> {
  const factory InvalidEmail({required final T failedValue}) =
      _$InvalidEmail<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidEmailCopyWith<T, _$InvalidEmail<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ShortPasswordCopyWith<T, $Res> {
  factory _$$ShortPasswordCopyWith(
          _$ShortPassword<T> value, $Res Function(_$ShortPassword<T>) then) =
      __$$ShortPasswordCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$ShortPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$ShortPassword<T>>
    implements _$$ShortPasswordCopyWith<T, $Res> {
  __$$ShortPasswordCopyWithImpl(
      _$ShortPassword<T> _value, $Res Function(_$ShortPassword<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
  }) {
    return _then(_$ShortPassword<T>(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$ShortPassword<T> implements ShortPassword<T> {
  const _$ShortPassword({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidPassword(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ShortPassword<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ShortPasswordCopyWith<T, _$ShortPassword<T>> get copyWith =>
      __$$ShortPasswordCopyWithImpl<T, _$ShortPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidPassword?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidPassword != null) {
      return invalidPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidPassword != null) {
      return invalidPassword(this);
    }
    return orElse();
  }
}

abstract class ShortPassword<T> implements ValueFailure<T> {
  const factory ShortPassword({required final T failedValue}) =
      _$ShortPassword<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$ShortPasswordCopyWith<T, _$ShortPassword<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidFullNameCopyWith<T, $Res> {
  factory _$$InvalidFullNameCopyWith(_$InvalidFullName<T> value,
          $Res Function(_$InvalidFullName<T>) then) =
      __$$InvalidFullNameCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidFullNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidFullName<T>>
    implements _$$InvalidFullNameCopyWith<T, $Res> {
  __$$InvalidFullNameCopyWithImpl(
      _$InvalidFullName<T> _value, $Res Function(_$InvalidFullName<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
  }) {
    return _then(_$InvalidFullName<T>(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidFullName<T> implements InvalidFullName<T> {
  const _$InvalidFullName({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidFullName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidFullName<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidFullNameCopyWith<T, _$InvalidFullName<T>> get copyWith =>
      __$$InvalidFullNameCopyWithImpl<T, _$InvalidFullName<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidFullName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidFullName?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidFullName != null) {
      return invalidFullName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidFullName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidFullName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidFullName != null) {
      return invalidFullName(this);
    }
    return orElse();
  }
}

abstract class InvalidFullName<T> implements ValueFailure<T> {
  const factory InvalidFullName({required final T failedValue}) =
      _$InvalidFullName<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidFullNameCopyWith<T, _$InvalidFullName<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidAddressCopyWith<T, $Res> {
  factory _$$InvalidAddressCopyWith(
          _$InvalidAddress<T> value, $Res Function(_$InvalidAddress<T>) then) =
      __$$InvalidAddressCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidAddressCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidAddress<T>>
    implements _$$InvalidAddressCopyWith<T, $Res> {
  __$$InvalidAddressCopyWithImpl(
      _$InvalidAddress<T> _value, $Res Function(_$InvalidAddress<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
  }) {
    return _then(_$InvalidAddress<T>(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidAddress<T> implements InvalidAddress<T> {
  const _$InvalidAddress({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidAddress(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidAddress<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidAddressCopyWith<T, _$InvalidAddress<T>> get copyWith =>
      __$$InvalidAddressCopyWithImpl<T, _$InvalidAddress<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidAddress(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidAddress?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidAddress != null) {
      return invalidAddress(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidAddress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidAddress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidAddress != null) {
      return invalidAddress(this);
    }
    return orElse();
  }
}

abstract class InvalidAddress<T> implements ValueFailure<T> {
  const factory InvalidAddress({required final T failedValue}) =
      _$InvalidAddress<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidAddressCopyWith<T, _$InvalidAddress<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidPhoneCopyWith<T, $Res> {
  factory _$$InvalidPhoneCopyWith(
          _$InvalidPhone<T> value, $Res Function(_$InvalidPhone<T>) then) =
      __$$InvalidPhoneCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidPhoneCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidPhone<T>>
    implements _$$InvalidPhoneCopyWith<T, $Res> {
  __$$InvalidPhoneCopyWithImpl(
      _$InvalidPhone<T> _value, $Res Function(_$InvalidPhone<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
  }) {
    return _then(_$InvalidPhone<T>(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidPhone<T> implements InvalidPhone<T> {
  const _$InvalidPhone({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidPhone(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidPhone<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidPhoneCopyWith<T, _$InvalidPhone<T>> get copyWith =>
      __$$InvalidPhoneCopyWithImpl<T, _$InvalidPhone<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidPhone(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidPhone?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidPhone != null) {
      return invalidPhone(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidPhone(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidPhone?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidPhone != null) {
      return invalidPhone(this);
    }
    return orElse();
  }
}

abstract class InvalidPhone<T> implements ValueFailure<T> {
  const factory InvalidPhone({required final T failedValue}) =
      _$InvalidPhone<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidPhoneCopyWith<T, _$InvalidPhone<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidImageUrlCopyWith<T, $Res> {
  factory _$$InvalidImageUrlCopyWith(_$InvalidImageUrl<T> value,
          $Res Function(_$InvalidImageUrl<T>) then) =
      __$$InvalidImageUrlCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidImageUrlCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidImageUrl<T>>
    implements _$$InvalidImageUrlCopyWith<T, $Res> {
  __$$InvalidImageUrlCopyWithImpl(
      _$InvalidImageUrl<T> _value, $Res Function(_$InvalidImageUrl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
  }) {
    return _then(_$InvalidImageUrl<T>(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidImageUrl<T> implements InvalidImageUrl<T> {
  const _$InvalidImageUrl({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidImageUrl(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidImageUrl<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidImageUrlCopyWith<T, _$InvalidImageUrl<T>> get copyWith =>
      __$$InvalidImageUrlCopyWithImpl<T, _$InvalidImageUrl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidImageUrl(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidImageUrl?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidImageUrl != null) {
      return invalidImageUrl(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidImageUrl(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidImageUrl?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidImageUrl != null) {
      return invalidImageUrl(this);
    }
    return orElse();
  }
}

abstract class InvalidImageUrl<T> implements ValueFailure<T> {
  const factory InvalidImageUrl({required final T failedValue}) =
      _$InvalidImageUrl<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidImageUrlCopyWith<T, _$InvalidImageUrl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidStringCopyWith<T, $Res> {
  factory _$$InvalidStringCopyWith(
          _$InvalidString<T> value, $Res Function(_$InvalidString<T>) then) =
      __$$InvalidStringCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidStringCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidString<T>>
    implements _$$InvalidStringCopyWith<T, $Res> {
  __$$InvalidStringCopyWithImpl(
      _$InvalidString<T> _value, $Res Function(_$InvalidString<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
  }) {
    return _then(_$InvalidString<T>(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidString<T> implements InvalidString<T> {
  const _$InvalidString({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidString(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidString<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidStringCopyWith<T, _$InvalidString<T>> get copyWith =>
      __$$InvalidStringCopyWithImpl<T, _$InvalidString<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidString(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidString?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidString != null) {
      return invalidString(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidString != null) {
      return invalidString(this);
    }
    return orElse();
  }
}

abstract class InvalidString<T> implements ValueFailure<T> {
  const factory InvalidString({required final T failedValue}) =
      _$InvalidString<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidStringCopyWith<T, _$InvalidString<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidCategoryCopyWith<T, $Res> {
  factory _$$InvalidCategoryCopyWith(_$InvalidCategory<T> value,
          $Res Function(_$InvalidCategory<T>) then) =
      __$$InvalidCategoryCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidCategoryCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidCategory<T>>
    implements _$$InvalidCategoryCopyWith<T, $Res> {
  __$$InvalidCategoryCopyWithImpl(
      _$InvalidCategory<T> _value, $Res Function(_$InvalidCategory<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
  }) {
    return _then(_$InvalidCategory<T>(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidCategory<T> implements InvalidCategory<T> {
  const _$InvalidCategory({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidCategory(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidCategory<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidCategoryCopyWith<T, _$InvalidCategory<T>> get copyWith =>
      __$$InvalidCategoryCopyWithImpl<T, _$InvalidCategory<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidCategory(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidCategory?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidCategory != null) {
      return invalidCategory(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidCategory(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidCategory?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidCategory != null) {
      return invalidCategory(this);
    }
    return orElse();
  }
}

abstract class InvalidCategory<T> implements ValueFailure<T> {
  const factory InvalidCategory({required final T failedValue}) =
      _$InvalidCategory<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidCategoryCopyWith<T, _$InvalidCategory<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidSubCategoryCopyWith<T, $Res> {
  factory _$$InvalidSubCategoryCopyWith(_$InvalidSubCategory<T> value,
          $Res Function(_$InvalidSubCategory<T>) then) =
      __$$InvalidSubCategoryCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidSubCategoryCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidSubCategory<T>>
    implements _$$InvalidSubCategoryCopyWith<T, $Res> {
  __$$InvalidSubCategoryCopyWithImpl(_$InvalidSubCategory<T> _value,
      $Res Function(_$InvalidSubCategory<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
  }) {
    return _then(_$InvalidSubCategory<T>(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidSubCategory<T> implements InvalidSubCategory<T> {
  const _$InvalidSubCategory({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidSubCategory(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidSubCategory<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidSubCategoryCopyWith<T, _$InvalidSubCategory<T>> get copyWith =>
      __$$InvalidSubCategoryCopyWithImpl<T, _$InvalidSubCategory<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidSubCategory(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidSubCategory?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidSubCategory != null) {
      return invalidSubCategory(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidSubCategory(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidSubCategory?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidSubCategory != null) {
      return invalidSubCategory(this);
    }
    return orElse();
  }
}

abstract class InvalidSubCategory<T> implements ValueFailure<T> {
  const factory InvalidSubCategory({required final T failedValue}) =
      _$InvalidSubCategory<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidSubCategoryCopyWith<T, _$InvalidSubCategory<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidImageCopyWith<T, $Res> {
  factory _$$InvalidImageCopyWith(
          _$InvalidImage<T> value, $Res Function(_$InvalidImage<T>) then) =
      __$$InvalidImageCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T? failedValue});
}

/// @nodoc
class __$$InvalidImageCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidImage<T>>
    implements _$$InvalidImageCopyWith<T, $Res> {
  __$$InvalidImageCopyWithImpl(
      _$InvalidImage<T> _value, $Res Function(_$InvalidImage<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidImage<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$InvalidImage<T> implements InvalidImage<T> {
  const _$InvalidImage({required this.failedValue});

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidImage(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidImage<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidImageCopyWith<T, _$InvalidImage<T>> get copyWith =>
      __$$InvalidImageCopyWithImpl<T, _$InvalidImage<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidImage(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidImage?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidImage != null) {
      return invalidImage(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidImage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidImage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidImage != null) {
      return invalidImage(this);
    }
    return orElse();
  }
}

abstract class InvalidImage<T> implements ValueFailure<T> {
  const factory InvalidImage({required final T? failedValue}) =
      _$InvalidImage<T>;

  T? get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidImageCopyWith<T, _$InvalidImage<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidDoubleCopyWith<T, $Res> {
  factory _$$InvalidDoubleCopyWith(
          _$InvalidDouble<T> value, $Res Function(_$InvalidDouble<T>) then) =
      __$$InvalidDoubleCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidDoubleCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidDouble<T>>
    implements _$$InvalidDoubleCopyWith<T, $Res> {
  __$$InvalidDoubleCopyWithImpl(
      _$InvalidDouble<T> _value, $Res Function(_$InvalidDouble<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
  }) {
    return _then(_$InvalidDouble<T>(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidDouble<T> implements InvalidDouble<T> {
  const _$InvalidDouble({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidDouble(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidDouble<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidDoubleCopyWith<T, _$InvalidDouble<T>> get copyWith =>
      __$$InvalidDoubleCopyWithImpl<T, _$InvalidDouble<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidDouble(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidDouble?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidDouble != null) {
      return invalidDouble(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidDouble(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidDouble?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidDouble != null) {
      return invalidDouble(this);
    }
    return orElse();
  }
}

abstract class InvalidDouble<T> implements ValueFailure<T> {
  const factory InvalidDouble({required final T failedValue}) =
      _$InvalidDouble<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidDoubleCopyWith<T, _$InvalidDouble<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidIntegerCopyWith<T, $Res> {
  factory _$$InvalidIntegerCopyWith(
          _$InvalidInteger<T> value, $Res Function(_$InvalidInteger<T>) then) =
      __$$InvalidIntegerCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidIntegerCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidInteger<T>>
    implements _$$InvalidIntegerCopyWith<T, $Res> {
  __$$InvalidIntegerCopyWithImpl(
      _$InvalidInteger<T> _value, $Res Function(_$InvalidInteger<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
  }) {
    return _then(_$InvalidInteger<T>(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidInteger<T> implements InvalidInteger<T> {
  const _$InvalidInteger({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidInteger(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidInteger<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidIntegerCopyWith<T, _$InvalidInteger<T>> get copyWith =>
      __$$InvalidIntegerCopyWithImpl<T, _$InvalidInteger<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidInteger(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidInteger?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidInteger != null) {
      return invalidInteger(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidInteger(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidInteger?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidInteger != null) {
      return invalidInteger(this);
    }
    return orElse();
  }
}

abstract class InvalidInteger<T> implements ValueFailure<T> {
  const factory InvalidInteger({required final T failedValue}) =
      _$InvalidInteger<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidIntegerCopyWith<T, _$InvalidInteger<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidListTooShortCopyWith<T, $Res> {
  factory _$$InvalidListTooShortCopyWith(_$InvalidListTooShort<T> value,
          $Res Function(_$InvalidListTooShort<T>) then) =
      __$$InvalidListTooShortCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidListTooShortCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidListTooShort<T>>
    implements _$$InvalidListTooShortCopyWith<T, $Res> {
  __$$InvalidListTooShortCopyWithImpl(_$InvalidListTooShort<T> _value,
      $Res Function(_$InvalidListTooShort<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
  }) {
    return _then(_$InvalidListTooShort<T>(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidListTooShort<T> implements InvalidListTooShort<T> {
  const _$InvalidListTooShort({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidListTooShort(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidListTooShort<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidListTooShortCopyWith<T, _$InvalidListTooShort<T>> get copyWith =>
      __$$InvalidListTooShortCopyWithImpl<T, _$InvalidListTooShort<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidListTooShort(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidListTooShort?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidListTooShort != null) {
      return invalidListTooShort(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidListTooShort(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidListTooShort?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidListTooShort != null) {
      return invalidListTooShort(this);
    }
    return orElse();
  }
}

abstract class InvalidListTooShort<T> implements ValueFailure<T> {
  const factory InvalidListTooShort({required final T failedValue}) =
      _$InvalidListTooShort<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidListTooShortCopyWith<T, _$InvalidListTooShort<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidDeliveryStatusCopyWith<T, $Res> {
  factory _$$InvalidDeliveryStatusCopyWith(_$InvalidDeliveryStatus<T> value,
          $Res Function(_$InvalidDeliveryStatus<T>) then) =
      __$$InvalidDeliveryStatusCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidDeliveryStatusCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidDeliveryStatus<T>>
    implements _$$InvalidDeliveryStatusCopyWith<T, $Res> {
  __$$InvalidDeliveryStatusCopyWithImpl(_$InvalidDeliveryStatus<T> _value,
      $Res Function(_$InvalidDeliveryStatus<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
  }) {
    return _then(_$InvalidDeliveryStatus<T>(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidDeliveryStatus<T> implements InvalidDeliveryStatus<T> {
  const _$InvalidDeliveryStatus({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidDeliveryStatus(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidDeliveryStatus<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidDeliveryStatusCopyWith<T, _$InvalidDeliveryStatus<T>>
      get copyWith =>
          __$$InvalidDeliveryStatusCopyWithImpl<T, _$InvalidDeliveryStatus<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidDeliveryStatus(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidDeliveryStatus?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidDeliveryStatus != null) {
      return invalidDeliveryStatus(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidDeliveryStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidDeliveryStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidDeliveryStatus != null) {
      return invalidDeliveryStatus(this);
    }
    return orElse();
  }
}

abstract class InvalidDeliveryStatus<T> implements ValueFailure<T> {
  const factory InvalidDeliveryStatus({required final T failedValue}) =
      _$InvalidDeliveryStatus<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidDeliveryStatusCopyWith<T, _$InvalidDeliveryStatus<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidPaymentStatusCopyWith<T, $Res> {
  factory _$$InvalidPaymentStatusCopyWith(_$InvalidPaymentStatus<T> value,
          $Res Function(_$InvalidPaymentStatus<T>) then) =
      __$$InvalidPaymentStatusCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidPaymentStatusCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidPaymentStatus<T>>
    implements _$$InvalidPaymentStatusCopyWith<T, $Res> {
  __$$InvalidPaymentStatusCopyWithImpl(_$InvalidPaymentStatus<T> _value,
      $Res Function(_$InvalidPaymentStatus<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
  }) {
    return _then(_$InvalidPaymentStatus<T>(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidPaymentStatus<T> implements InvalidPaymentStatus<T> {
  const _$InvalidPaymentStatus({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidPaymentStatus(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidPaymentStatus<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidPaymentStatusCopyWith<T, _$InvalidPaymentStatus<T>> get copyWith =>
      __$$InvalidPaymentStatusCopyWithImpl<T, _$InvalidPaymentStatus<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) invalidPassword,
    required TResult Function(T failedValue) invalidFullName,
    required TResult Function(T failedValue) invalidAddress,
    required TResult Function(T failedValue) invalidPhone,
    required TResult Function(T failedValue) invalidImageUrl,
    required TResult Function(T failedValue) invalidString,
    required TResult Function(T failedValue) invalidCategory,
    required TResult Function(T failedValue) invalidSubCategory,
    required TResult Function(T? failedValue) invalidImage,
    required TResult Function(T failedValue) invalidDouble,
    required TResult Function(T failedValue) invalidInteger,
    required TResult Function(T failedValue) invalidListTooShort,
    required TResult Function(T failedValue) invalidDeliveryStatus,
    required TResult Function(T failedValue) invalidPaymentStatus,
  }) {
    return invalidPaymentStatus(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidEmail,
    TResult? Function(T failedValue)? invalidPassword,
    TResult? Function(T failedValue)? invalidFullName,
    TResult? Function(T failedValue)? invalidAddress,
    TResult? Function(T failedValue)? invalidPhone,
    TResult? Function(T failedValue)? invalidImageUrl,
    TResult? Function(T failedValue)? invalidString,
    TResult? Function(T failedValue)? invalidCategory,
    TResult? Function(T failedValue)? invalidSubCategory,
    TResult? Function(T? failedValue)? invalidImage,
    TResult? Function(T failedValue)? invalidDouble,
    TResult? Function(T failedValue)? invalidInteger,
    TResult? Function(T failedValue)? invalidListTooShort,
    TResult? Function(T failedValue)? invalidDeliveryStatus,
    TResult? Function(T failedValue)? invalidPaymentStatus,
  }) {
    return invalidPaymentStatus?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? invalidPassword,
    TResult Function(T failedValue)? invalidFullName,
    TResult Function(T failedValue)? invalidAddress,
    TResult Function(T failedValue)? invalidPhone,
    TResult Function(T failedValue)? invalidImageUrl,
    TResult Function(T failedValue)? invalidString,
    TResult Function(T failedValue)? invalidCategory,
    TResult Function(T failedValue)? invalidSubCategory,
    TResult Function(T? failedValue)? invalidImage,
    TResult Function(T failedValue)? invalidDouble,
    TResult Function(T failedValue)? invalidInteger,
    TResult Function(T failedValue)? invalidListTooShort,
    TResult Function(T failedValue)? invalidDeliveryStatus,
    TResult Function(T failedValue)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidPaymentStatus != null) {
      return invalidPaymentStatus(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) invalidPassword,
    required TResult Function(InvalidFullName<T> value) invalidFullName,
    required TResult Function(InvalidAddress<T> value) invalidAddress,
    required TResult Function(InvalidPhone<T> value) invalidPhone,
    required TResult Function(InvalidImageUrl<T> value) invalidImageUrl,
    required TResult Function(InvalidString<T> value) invalidString,
    required TResult Function(InvalidCategory<T> value) invalidCategory,
    required TResult Function(InvalidSubCategory<T> value) invalidSubCategory,
    required TResult Function(InvalidImage<T> value) invalidImage,
    required TResult Function(InvalidDouble<T> value) invalidDouble,
    required TResult Function(InvalidInteger<T> value) invalidInteger,
    required TResult Function(InvalidListTooShort<T> value) invalidListTooShort,
    required TResult Function(InvalidDeliveryStatus<T> value)
        invalidDeliveryStatus,
    required TResult Function(InvalidPaymentStatus<T> value)
        invalidPaymentStatus,
  }) {
    return invalidPaymentStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidEmail<T> value)? invalidEmail,
    TResult? Function(ShortPassword<T> value)? invalidPassword,
    TResult? Function(InvalidFullName<T> value)? invalidFullName,
    TResult? Function(InvalidAddress<T> value)? invalidAddress,
    TResult? Function(InvalidPhone<T> value)? invalidPhone,
    TResult? Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult? Function(InvalidString<T> value)? invalidString,
    TResult? Function(InvalidCategory<T> value)? invalidCategory,
    TResult? Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult? Function(InvalidImage<T> value)? invalidImage,
    TResult? Function(InvalidDouble<T> value)? invalidDouble,
    TResult? Function(InvalidInteger<T> value)? invalidInteger,
    TResult? Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult? Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult? Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
  }) {
    return invalidPaymentStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? invalidPassword,
    TResult Function(InvalidFullName<T> value)? invalidFullName,
    TResult Function(InvalidAddress<T> value)? invalidAddress,
    TResult Function(InvalidPhone<T> value)? invalidPhone,
    TResult Function(InvalidImageUrl<T> value)? invalidImageUrl,
    TResult Function(InvalidString<T> value)? invalidString,
    TResult Function(InvalidCategory<T> value)? invalidCategory,
    TResult Function(InvalidSubCategory<T> value)? invalidSubCategory,
    TResult Function(InvalidImage<T> value)? invalidImage,
    TResult Function(InvalidDouble<T> value)? invalidDouble,
    TResult Function(InvalidInteger<T> value)? invalidInteger,
    TResult Function(InvalidListTooShort<T> value)? invalidListTooShort,
    TResult Function(InvalidDeliveryStatus<T> value)? invalidDeliveryStatus,
    TResult Function(InvalidPaymentStatus<T> value)? invalidPaymentStatus,
    required TResult orElse(),
  }) {
    if (invalidPaymentStatus != null) {
      return invalidPaymentStatus(this);
    }
    return orElse();
  }
}

abstract class InvalidPaymentStatus<T> implements ValueFailure<T> {
  const factory InvalidPaymentStatus({required final T failedValue}) =
      _$InvalidPaymentStatus<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidPaymentStatusCopyWith<T, _$InvalidPaymentStatus<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
